From f346e8153bbe325924d751bd3ccdd830b88f2671 Mon Sep 17 00:00:00 2001
From: Brian Kroth <bpkroth@gmail.com>
Date: Mon, 18 Jul 2016 13:24:08 -0500
Subject: [PATCH 2/4] Fix timestamp that GetLastLock() uses to determine when
 a do action sequence was last performed.

Work to make GetLastLock(), as called in various do.c functions from
DoTree(), check the first time an action sequence pass happened, rather
than the first time DoTree() was called.

This is a related to the bug/fix in f6658d41 - if the lock names aren't
unique for a given set of actions, and a preceeding action sequence pass
took longer than 1 minute, then checking the initial DoTree() timestamp
will cause the colliding lock name actions to skip all but the first
action in the set.

If we instead check the timestamp of the first time the action sequence
was run, then we may still collide, but the timestamp check (probably)
won't prevent the colliding actions from also being performed.

NOTE: This commit (somewhat intentionally) hasn't addressed all calls to
GetLock(...,CFSTARTTIME) due in part to multiple possible call path
timestamp comparison complications.
---
 src/cf.defs.h    |    1 +
 src/cf.extern.h  |    1 +
 src/cfagent.c    |    5 +++-
 src/do.c         |   14 +++++------
 src/globals.c    |    2 ++
 src/nameinfo.c   |   70 ++++++++++++++++++++++++++++++++++++++++++++++++++++++
 src/prototypes.h |    3 +++
 7 files changed, 88 insertions(+), 8 deletions(-)

--- a/src/cf.defs.h
+++ b/src/cf.defs.h
@@ -1058,6 +1058,7 @@
 
 /*******************************************************************/
 
+#define ENUM_ASEQ_SIZE 25		// verified by hand :P
 enum aseq
    {
    mkpaths,
--- a/src/cf.extern.h
+++ b/src/cf.extern.h
@@ -146,6 +146,7 @@
 extern int NUMBEROFEDITS;
 extern time_t CFSTARTTIME;
 extern time_t CFINITSTARTTIME;
+extern time_t CFACTIONSEQSTARTTIMES[];
 extern int CF_TIMEOUT;
 
 extern struct utsname VSYSNAME;
--- a/src/cfagent.c
+++ b/src/cfagent.c
@@ -1204,6 +1204,7 @@
 
 Debug("DoTree(%d,%s)\n",passes,info);
  
+ResetActionSeqStartTimes();
 for (PASS = 1; PASS <= passes; PASS++)
    {
    for (action = VACTIONSEQ; action !=NULL; action=action->next)
@@ -1234,7 +1235,9 @@
       Verbose(" %s Sched: %s pass %d @ %s",info,action->name,PASS,ctime(&CFINITSTARTTIME));
       Verbose("*********************************************************************\n\n");
       
-      switch (EvaluateAction(action->name,&VADDCLASSES,PASS))
+      enum aseq action_seq = EvaluateAction(action->name,&VADDCLASSES,PASS);
+      SetActionSeqStartTime(action_seq);
+      switch (action_seq)
          {
          case mountinfo:
              if (PASS == 1)
--- a/src/do.c
+++ b/src/do.c
@@ -404,7 +404,7 @@
 
    snprintf(VBUFF,CF_BUFSIZE,"%.*s.%.*s",(CF_BUFSIZE-2)/2,lp->from,(CF_BUFSIZE-2)/2,lp->to); /* Unique ID for copy locking */
 
-   if (!GetLock(ASUniqueName("link"),CanonifyName(VBUFF),lp->ifelapsed,lp->expireafter,VUQNAME,CFSTARTTIME))
+   if (!GetLock(ASUniqueName("link"),CanonifyName(VBUFF),lp->ifelapsed,lp->expireafter,VUQNAME,GetActionSeqStartTime(lnks)))
       {
       lp->done = 'y';
       continue;
@@ -519,7 +519,7 @@
 
    snprintf(VBUFF,CF_BUFSIZE,"%.*s.%.*s",(CF_BUFSIZE-2)/2,lp->from,(CF_BUFSIZE-2)/2,lp->to); /* Unique ID for copy locking */
    
-   if (!GetLock(ASUniqueName("link"),CanonifyName(VBUFF),lp->ifelapsed,lp->expireafter,VUQNAME,CFSTARTTIME))
+   if (!GetLock(ASUniqueName("link"),CanonifyName(VBUFF),lp->ifelapsed,lp->expireafter,VUQNAME,GetActionSeqStartTime(lnks)))
       {
       lp->done = 'y';
       continue;
@@ -611,7 +611,7 @@
   char lmailpath[CF_BUFSIZE];
 
 
-if (!GetLock("Mailcheck",CanonifyName(VFSTAB[VSYSTEMHARDCLASS]),0,VEXPIREAFTER,VUQNAME,CFSTARTTIME))
+if (!GetLock("Mailcheck",CanonifyName(VFSTAB[VSYSTEMHARDCLASS]),0,VEXPIREAFTER,VUQNAME,GetActionSeqStartTime(chkmail)))
    {
    return;
    }
@@ -1270,7 +1270,7 @@
    ResetOutputRoute(ptr->log,ptr->inform);
    ExpandVarstring(ptr->name,execstr,NULL);
 
-   if (!GetLock(ASUniqueName("shellcommand"),execstr,ptr->ifelapsed,ptr->expireafter,VUQNAME,CFSTARTTIME))
+   if (!GetLock(ASUniqueName("shellcommand"),execstr,ptr->ifelapsed,ptr->expireafter,VUQNAME,GetActionSeqStartTime(shellcom)))
       {
       ptr->done = 'y';
       continue;
@@ -2585,7 +2585,7 @@
       
       snprintf(vbuff,CF_BUFSIZE,"%.*s.%.*s_%.128s",(CF_BUFSIZE-132)/2,path,(CF_BUFSIZE-132)/2,destination,server); /* Unique ID for copy locking */
       
-      if (!GetLock(ASUniqueName("copy"),CanonifyName(vbuff),ip->ifelapsed,ip->expireafter,VUQNAME,CFSTARTTIME))
+      if (!GetLock(ASUniqueName("copy"),CanonifyName(vbuff),ip->ifelapsed,ip->expireafter,VUQNAME,GetActionSeqStartTime(imag)))
          {
          SILENT = savesilent;
          ResetOutputRoute('d','d');
@@ -2793,7 +2793,7 @@
 
    snprintf(VBUFF,CF_BUFSIZE-1,"proc-%s-%s",pp->expr,pp->restart);
    
-   if (!GetLock(ASUniqueName("processes"),CanonifyName(VBUFF),pp->ifelapsed,pp->expireafter,VUQNAME,CFSTARTTIME))
+   if (!GetLock(ASUniqueName("processes"),CanonifyName(VBUFF),pp->ifelapsed,pp->expireafter,VUQNAME,GetActionSeqStartTime(procs)))
       {
       pp->done = 'y';
       continue;
@@ -2848,7 +2848,7 @@
    
    snprintf(lock,CF_BUFSIZE-1,"%s_%d_%s_%d_%s_%s", name, ptr->cmp, ptr->ver ? ptr->ver: "" ,ptr->action, ptr->defines ?: "", ptr->elsedef ?: "");
    
-   if (!GetLock(ASUniqueName("packages"),CanonifyName(lock),ptr->ifelapsed,ptr->expireafter,VUQNAME,CFSTARTTIME))
+   if (!GetLock(ASUniqueName("packages"),CanonifyName(lock),ptr->ifelapsed,ptr->expireafter,VUQNAME,GetActionSeqStartTime(pkgs)))
       {
       ptr->done = 'y';
       continue;
--- a/src/globals.c
+++ b/src/globals.c
@@ -165,6 +165,8 @@
   PUBLIC time_t CFSTARTTIME;
   PUBLIC time_t CFINITSTARTTIME;
 
+  PUBLIC time_t CFACTIONSEQSTARTTIMES[ENUM_ASEQ_SIZE] = {0};
+
   PUBLIC dev_t ROOTDEVICE = 0;
 
   PUBLIC char  STR_CFENGINEPORT[16];
--- a/src/nameinfo.c
+++ b/src/nameinfo.c
@@ -891,6 +891,76 @@
 
 /*******************************************************************/
 
+void ResetActionSeqStartTimes()
+
+{
+Debug("Resetting initial action seq job start times\n");
+
+memset(CFACTIONSEQSTARTTIMES, 0, sizeof(time_t) * ENUM_ASEQ_SIZE);
+}
+
+/*******************************************************************/
+
+void SetActionSeqStartTime(enum aseq action_seq)
+
+{ time_t tloc;
+
+int action_seq_index = (int)action_seq;
+if (action_seq_index >= ENUM_ASEQ_SIZE || action_seq_index < 0)
+{
+  char vbuff[CF_BUFSIZE];
+  snprintf(vbuff, CF_BUFSIZE, "Invalid CFACTIONSEQSTARTTIMES index %d!\n", action_seq_index);
+  CfLog(cferror,vbuff,"SetActionSeqStartTime");
+  exit(1);
+}
+
+time_t tlast = CFACTIONSEQSTARTTIMES[action_seq_index];
+if (tlast != 0)
+{
+  Debug("%s job start time already set to %s\n",
+    (action_seq != plugin) ? ACTIONSEQTEXT[action_seq_index] : "module",ctime(&tlast));
+  return;
+}
+
+if ((tloc = time((time_t *)NULL)) == -1)
+   {
+   CfLog(cferror,"Couldn't read system clock\n","");
+   }
+
+CFACTIONSEQSTARTTIMES[action_seq_index] = tloc;
+
+Debug("%s job start time set to %s\n",
+  (action_seq != plugin) ? ACTIONSEQTEXT[action_seq_index] : "module",ctime(&tloc));
+}
+
+/*******************************************************************/
+
+time_t GetActionSeqStartTime(enum aseq action_seq)
+
+{ time_t tlast;
+
+int action_seq_index = (int)action_seq;
+if (action_seq_index >= ENUM_ASEQ_SIZE || action_seq_index < 0)
+{
+  char vbuff[CF_BUFSIZE];
+  snprintf(vbuff, CF_BUFSIZE, "Invalid CFACTIONSEQSTARTTIMES index %d!\n", action_seq_index);
+  CfLog(cferror,vbuff,"GetActionSeqStartTime");
+  exit(1);
+}
+
+tlast = CFACTIONSEQSTARTTIMES[action_seq_index];
+if (tlast == 0)
+{
+  tlast = CFSTARTTIME;
+  Debug("%s job start time unavailable, using CFSTARTTIME %s instead\n",
+    (action_seq != plugin) ? ACTIONSEQTEXT[action_seq_index] : "module",CFSTARTTIME);
+}
+
+return tlast;
+}
+
+/*******************************************************************/
+
 void BuildClassEnvironment()
 
 { struct Item *ip;
--- a/src/prototypes.h
+++ b/src/prototypes.h
@@ -795,6 +795,9 @@
 
 void SetReferenceTime(int setclasses);
 void SetStartTime(int setclasses);
+time_t GetActionSeqStartTime(enum aseq action_seq);
+void SetActionSeqStartTime(enum aseq action_seq);
+void ResetActionSeqStartTimes(void);
 
 /* modes.c */
 
